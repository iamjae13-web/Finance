name: GLD_TLT_SellSignal_Monitor

on:
  schedule:
    - cron: "0 * * * *"   # ë§¤ ì •ê° ì‹¤í–‰ (1ì‹œê°„ë§ˆë‹¤)
  workflow_dispatch:

jobs:
  monitor:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests pandas numpy yfinance openpyxl beautifulsoup4 lxml

      - name: Run GLD/TLT sell-signal monitor
        env:
          TELEGRAM_TOKEN: ${{ secrets.TELEGRAM_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
          FRED_API_KEY: ${{ secrets.FRED_API_KEY }}
          FINRA_PAGE_URL: ${{ secrets.FINRA_PAGE_URL }}
          BUFFET_CSV_URL: ${{ secrets.BUFFET_CSV_URL }}
        run: |
          python3 - <<'PYCODE'
          import os, requests, io, re, math
          import pandas as pd, numpy as np
          import yfinance as yf
          from datetime import datetime, timedelta
          from bs4 import BeautifulSoup

          # í™˜ê²½ë³€ìˆ˜
          TOKEN = os.getenv("TELEGRAM_TOKEN")
          CHAT_ID = os.getenv("TELEGRAM_CHAT_ID")
          FRED_KEY = os.getenv("FRED_API_KEY")
          FINRA_PAGE_URL = os.getenv("FINRA_PAGE_URL") or "https://www.finra.org/rules-guidance/key-topics/margin-accounts/margin-statistics"
          BUFFET_CSV_URL = os.getenv("BUFFET_CSV_URL")

          now = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S UTC")

          def telegram_send(text):
              if not TOKEN or not CHAT_ID:
                  print("í…”ë ˆê·¸ë¨ ì„¤ì • ëˆ„ë½")
                  return False
              url = f"https://api.telegram.org/bot{TOKEN}/sendMessage"
              try:
                  r = requests.post(url, data={"chat_id": CHAT_ID, "text": text}, timeout=15)
                  print("telegram status", r.status_code)
                  return r.status_code == 200
              except Exception as e:
                  print("telegram error", e)
                  return False

          # ---------- data helpers ----------
          def fred_latest(series_id):
              url = "https://api.stlouisfed.org/fred/series/observations"
              params = {"series_id": series_id, "api_key": FRED_KEY, "file_type":"json", "limit":1, "sort_order":"desc"}
              try:
                  r = requests.get(url, params=params, timeout=20); r.raise_for_status()
                  j = r.json().get("observations", [])
                  if not j: return None
                  v = j[0].get("value")
                  if v in (".", "", None): return None
                  return float(v)
              except Exception as e:
                  print("fred_latest error", series_id, e)
                  return None

          def fred_series(series_id, days=200):
              url = "https://api.stlouisfed.org/fred/series/observations"
              params = {"series_id": series_id, "api_key": FRED_KEY, "file_type":"json", "limit":days, "sort_order":"desc"}
              try:
                  r = requests.get(url, params=params, timeout=30); r.raise_for_status()
                  obs = r.json().get("observations", [])
                  if not obs: return []
                  vals = [float(o["value"]) for o in obs if o.get("value") not in (".", "", None)]
                  return vals[::-1]  # chronological
              except Exception as e:
                  print("fred_series error", series_id, e)
                  return []

          def fetch_finra_margin():
              try:
                  r = requests.get(FINRA_PAGE_URL, timeout=20); r.raise_for_status()
                  soup = BeautifulSoup(r.text, "lxml")
                  links = []
                  for a in soup.find_all("a", href=True):
                      href = a['href']
                      if re.search(r'\.xls[x]?$', href, re.IGNORECASE):
                          links.append(href if href.startswith("http") else requests.compat.urljoin(FINRA_PAGE_URL, href))
                  for link in links:
                      try:
                          rr = requests.get(link, timeout=30); rr.raise_for_status()
                          df = pd.read_excel(io.BytesIO(rr.content), header=None)
                          # ë§ˆì§€ë§‰ 20í–‰ íƒìƒ‰
                          found = []
                          for r_i in range(max(0, df.shape[0]-20), df.shape[0]):
                              for cell in df.iloc[r_i]:
                                  s = str(cell)
                                  if re.search(r'[\d\$,]{3,}', s):
                                      s2 = re.sub(r'[^0-9.\-]', '', s)
                                      try:
                                          found.append(float(s2))
                                      except:
                                          pass
                          if found:
                              return sorted(found)[-1]
                      except Exception as e:
                          continue
              except Exception as e:
                  print("fetch_finra error", e)
              return None

          # ---------- price helpers (yfinance) ----------
          def get_hist(ticker, period="6mo", interval="1d"):
              try:
                  t = yf.Ticker(ticker)
                  df = t.history(period=period, interval=interval)
                  if df is None or df.empty:
                      return None
                  return df
              except Exception as e:
                  print("yfinance error", ticker, e)
                  return None

          def compute_RSI(series, window=14):
              # series: pandas Series of close prices
              delta = series.diff()
              up = delta.clip(lower=0)
              down = -1*delta.clip(upper=0)
              ma_up = up.ewm(com=window-1, adjust=False).mean()
              ma_down = down.ewm(com=window-1, adjust=False).mean()
              rs = ma_up / ma_down
              rsi = 100 - (100 / (1 + rs))
              return rsi

          # ---------- signal checks per group ----------
          # Group 1: ê¸ˆë¦¬ ì „í™˜ (TLT ì£¼ë¡œ ì ìš©)
          def signal_rate_transition():
              # 10y ìµœê·¼ ë³€í™”(20ì¼ ëŒ€ë¹„)
              dgs10_series = fred_series("DGS10", days=60)
              if len(dgs10_series) < 25:
                  return False, "DGS10 ë°ì´í„° ë¶€ì¡±"
              recent = dgs10_series[-1]
              past20 = dgs10_series[-21]
              # 20ì¼ ëŒ€ë¹„ 0.25%p ì´ìƒ ìƒìŠ¹ ì „í™˜
              cond = (recent - past20) >= 0.25
              reason = f"10y change: {recent - past20:.3f}"
              return cond, reason

          def signal_yield_curve_normalizing():
              # ì—­ì „â†’ì •ìƒí™” ì—¬ë¶€ (10y-2y)
              y10 = fred_latest("DGS10"); y2 = fred_latest("DGS2")
              if y10 is None or y2 is None:
                  return False, "10y/2y ë°ì´í„° ë¶€ì¡±"
              yc = y10 - y2
              # ê¸°ì¤€: 10y-2yê°€ +0.5%p ì´ìƒ
              cond = yc >= 0.5
              return cond, f"10y-2y={yc:.3f}"

          def signal_real_rate_rising():
              # ì‹¤ì§ˆê¸ˆë¦¬(10y - TIPS10) ìƒìŠ¹ 3ì£¼ ì—°ì†
              dgs10 = fred_series("DGS10", days=30)
              tips = fred_series("DFII10", days=30)  # DFII10ëŠ” ì˜ˆì‹œ(ì‹¤ì§ˆê¸ˆë¦¬ ì‹œë¦¬ì¦ˆ ê°€ìš©ì„± í™•ì¸ í•„ìš”)
              if not dgs10 or not tips or len(dgs10)<21 or len(tips)<21:
                  return False, "ì‹¤ì§ˆê¸ˆë¦¬ ë°ì´í„° ë¶€ì¡±"
              real = np.array(dgs10[-21:]) - np.array(tips[-21:])
              # ìµœê·¼ 3ì£¼(15ê±°ë˜ì¼ ~ 3ì£¼) ì—°ì† ìƒìŠ¹ íŒë‹¨: ìµœê·¼ 3 ê°’ì´ ì¦ê°€ ì¶”ì„¸
              if len(real) < 15:
                  return False, "ì‹¤ì§ˆê¸ˆë¦¬ ì‹œê³„ì—´ ì§§ìŒ"
              recent = real[-15:]
              cond = (recent[-1] > recent[-6]) and (recent[-6] > recent[-11])
              return bool(cond), f"real last:{recent[-1]:.3f}"

          # Group 2: ì‹¤ë¬¼ íšŒë³µ (PMI/ì‹¤ì—…/GDPNow) - ì¼ë¶€ëŠ” ì™¸ë¶€ ì†ŒìŠ¤ê°€ í•„ìš”í•˜ë¯€ë¡œ ê°€ëŠ¥í•˜ë©´ ëŒ€ì²´
          def signal_real_activity():
              # ëŒ€ì²´: SP500 30ì¼ ëª¨ë©˜í…€(ì£¼ì‹ ê°•ì„¸ëŠ” ê²½ê¸° íšŒë³µê³¼ ì—°ë™ë  ìˆ˜ ìˆìŒ)
              sp = get_hist("^GSPC", period="6mo")
              if sp is None or sp.empty:
                  return False, "SP500 ë°ì´í„° ë¶€ì¡±"
              close = sp['Close']
              mom30 = (close.iloc[-1] / close.iloc[-31] - 1) * 100 if len(close)>31 else 0
              cond = mom30 > 2.0  # 30ì¼ ë‚´ 2% ì´ìƒ ìƒìŠ¹ì´ë©´ ê²½ê¸° ëª¨ë©˜í…€ìœ¼ë¡œ ê°„ì£¼(ëŒ€ì²´ì§€í‘œ)
              return cond, f"SP500 30d mom {mom30:.2f}%"

          # Group 3: ìœ„í—˜ìì‚° ì„ í˜¸
          def signal_risk_on():
              vix = get_hist("^VIX", period="3mo")
              hy_oas = fred_latest("BAMLH0A0HYM2")
              sp = get_hist("^GSPC", period="3mo")
              reasons = []
              conds = []
              if vix is not None and not vix.empty:
                  vix_now = vix['Close'].iloc[-1]
                  conds.append(vix_now <= 15)
                  reasons.append(f"VIX {vix_now:.1f}")
              else:
                  reasons.append("VIX missing")
              if hy_oas is not None:
                  conds.append(hy_oas <= 350)
                  reasons.append(f"HY OAS {hy_oas}")
              else:
                  reasons.append("HY missing")
              if sp is not None and not sp.empty:
                  close = sp['Close']
                  above50 = close.iloc[-1] > close.rolling(window=50).mean().iloc[-1] if len(close)>50 else False
                  conds.append(bool(above50))
                  reasons.append(f"SP50 MA above {above50}")
              # majority true -> risk-on
              true_count = sum([1 for c in conds if c])
              cond = true_count >= 2
              return cond, "; ".join(reasons)

          # Group 4: ìì‚° ìì²´ ê³¼ì—´ (RSI, MA deviation)
          def signal_asset_overheat(ticker, asset_name):
              df = get_hist(ticker, period="6mo")
              if df is None or df.empty:
                  return False, f"{asset_name} price missing"
              close = df['Close'].dropna()
              if len(close) < 60:
                  return False, f"{asset_name} series too short"
              rsi = compute_RSI(close, window=14)
              rsi_now = rsi.iloc[-1]
              ma20 = close.rolling(window=20).mean().iloc[-1]
              dev20 = (close.iloc[-1] / ma20 - 1) * 100
              # ê¸°ì¤€: RSI TLT>=65 GLD>=70, dev20 TLT>=5% GLD>=6%
              if asset_name == "TLT":
                  conds = [rsi_now >= 65, dev20 >= 5.0]
              else:
                  conds = [rsi_now >= 70, dev20 >= 6.0]
              true_count = sum(1 for c in conds if c)
              reason = f"RSI={rsi_now:.1f}, dev20={dev20:.2f}%"
              return (true_count >= 2), reason

          # Group 5: ìƒê´€êµ¬ì¡° ë¶•ê´´ (TLT/SPY, GLD/SPY correlations)
          def signal_corr_change(ticker_asset, ticker_ref="SPY"):
              # ìµœê·¼ 20ì¼ ìƒê´€ê³„ìˆ˜ ê³„ì‚°
              df_asset = get_hist(ticker_asset, period="3mo")
              df_ref = get_hist(ticker_ref, period="3mo")
              if df_asset is None or df_ref is None:
                  return False, "price missing"
              common = pd.concat([df_asset['Close'], df_ref['Close']], axis=1, join='inner').dropna()
              if common.shape[0] < 30:
                  return False, "insufficient overlap"
              corr = common.iloc[-30:,:].corr().iloc[0,1]
              # ìƒê´€ê³„ìˆ˜ê°€ +0.2 ì´ìƒì´ë©´ ì•ˆì „ìì‚° ì—­í•  ì•½í™”(ìš°ë¦¬ ê¸°ì¤€)
              return (corr >= 0.2), f"corr={corr:.2f}"

          # ---------- orchestrate signals for TLT and GLD ----------
          assets = {
              "TLT": {"ticker":"TLT", "signals":[]},
              "GLD": {"ticker":"GLD", "signals":[]}
          }

          # Gather common metrics once
          try:
              hy_oas_val = fred_latest("BAMLH0A0HYM2")
          except:
              hy_oas_val = None
          try:
              margin_val = fetch_finra_margin()
          except:
              margin_val = None

          # Evaluate signals per asset
          for name, meta in assets.items():
              sig_list = []
              # 1) ê¸ˆë¦¬ ì „í™˜ (TLT ì¤‘ì‹¬ but applied to both as condition)
              s1, r1 = signal_rate_transition()
              sig_list.append(("ê¸ˆë¦¬ì „í™˜", bool(s1), r1))
              # 1b) yield curve normalize
              s1b, r1b = signal_yield_curve_normalizing()
              sig_list.append(("ì—­ì „->ì •ìƒí™”", bool(s1b), r1b))
              # 1c) ì‹¤ì§ˆê¸ˆë¦¬
              s1c, r1c = signal_real_rate_rising()
              sig_list.append(("ì‹¤ì§ˆê¸ˆë¦¬ìƒìŠ¹", bool(s1c), r1c))

              # 2) ì‹¤ë¬¼ íšŒë³µ
              s2, r2 = signal_real_activity()
              sig_list.append(("ì‹¤ë¬¼íšŒë³µ(ëŒ€ì²´)", bool(s2), r2))

              # 3) ìœ„í—˜ìì‚° ì„ í˜¸
              s3, r3 = signal_risk_on()
              sig_list.append(("ìœ„í—˜ì„ í˜¸í™•ëŒ€", bool(s3), r3))

              # 4) ìì‚° ìì²´ ê³¼ì—´ (RSI+MA dev)
              s4, r4 = signal_asset_overheat(meta["ticker"], name)
              sig_list.append(("ìì‚°ê³¼ì—´", bool(s4), r4))

              # 5) ìƒê´€êµ¬ì¡° ë³€í™”
              s5, r5 = signal_corr_change(meta["ticker"], "SPY")
              sig_list.append(("ìƒê´€êµ¬ì¡°ë¶•ê´´", bool(s5), r5))

              meta["signals"] = sig_list

          # ---------- decide and build message ----------
          alerts = []
          for name, meta in assets.items():
              checks = meta["signals"]
              true_count = sum(1 for t,flag,reason in checks if flag)
              details = "\n".join([f"â€¢ {title}: {'Y' if flag else 'N'} ({reason})" for title,flag,reason in checks])
              if true_count >= 3:
                  text = f"ğŸ“‰ [{name}] ë§¤ë„ ì‹ í˜¸ ë°œìƒ ({true_count}/5)\n\nê·¼ê±°:\n{details}\n\nì°¸ê³ : ìë™ ë§¤ë„ ì•„ë‹˜ â€” ìˆ˜ë™ íŒë‹¨ í•„ìš”"
                  alerts.append(text)

          # send alerts if any
          if alerts:
              # combine and send (separate messages)
              for msg in alerts:
                  telegram_send(msg)
                  print("Sent alert for asset.")
          else:
              print(now, "- ë§¤ë„ ì‹ í˜¸ ì—†ìŒ.")

          PYCODE
