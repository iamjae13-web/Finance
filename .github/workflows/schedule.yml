name: ETF_GLDTLTQQQ_Monitor

on:
  schedule:
    - cron: '0 * * * *'   # ë§¤ ì •ê° ì‹¤í–‰
  workflow_dispatch:

jobs:
  monitor:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install Python deps
        run: |
          python -m pip install --upgrade pip
          pip install requests pandas numpy yfinance

      - name: Run ETF Detailed Monitor
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
          FRED_API_KEY: ${{ secrets.FRED_API_KEY }}
        run: |
          python - <<'PY'
          import os, sys, requests, pandas as pd, numpy as np, yfinance as yf
          from datetime import datetime

          BOT = os.getenv("TELEGRAM_BOT_TOKEN")
          CHAT = os.getenv("TELEGRAM_CHAT_ID")
          FRED_KEY = os.getenv("FRED_API_KEY")
          if not BOT or not CHAT or not FRED_KEY:
              sys.exit("ERROR: í•„ìˆ˜ Secrets ëˆ„ë½")

          now = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S UTC")

          # ---------- ìœ í‹¸ ----------
          def yf_close_series(ticker, period="3y"):
              df = yf.Ticker(ticker).history(period=period)["Close"]
              return df.dropna() if df is not None else pd.Series(dtype=float)

          def fred_series(series_id, limit=400):
              url = "https://api.stlouisfed.org/fred/series/observations"
              params = {"series_id":series_id,"api_key":FRED_KEY,"file_type":"json","limit":limit,"sort_order":"desc"}
              r = requests.get(url, params=params, timeout=30); r.raise_for_status()
              obs = r.json().get("observations", [])
              vals = [(o.get("date"), o.get("value")) for o in obs if o.get("value") not in (".","",None)]
              df = pd.DataFrame(vals, columns=["date","value"])
              df["value"]=pd.to_numeric(df["value"], errors="coerce"); df["date"]=pd.to_datetime(df["date"])
              return df.set_index("date")["value"].sort_index()

          def compute_rsi(series, period=14):
              delta = series.diff()
              up = delta.clip(lower=0); down=-delta.clip(upper=0)
              ma_up = up.rolling(period).mean(); ma_down = down.rolling(period).mean()
              rs = ma_up / ma_down
              rsi = 100 - (100 / (1+rs))
              return rsi

          def score_directional(val, dir_high=True):
              if val is None or np.isnan(val): return 0.0
              sc = val/(abs(val)+10) if dir_high else (10-val)/(10+abs(val))
              return max(0.0, min(1.0, sc))

          def dynamic_allocation(score):
              return round(score*100)

          def decide_label(score):
              if score<0.4: return "ìœ ì§€"
              if score<0.7: return "1ì°¨ë§¤ìˆ˜/ë§¤ë„"
              if score<0.9: return "2ì°¨ë§¤ìˆ˜/ë§¤ë„"
              return "ê°•ë ¥ë§¤ìˆ˜/ë§¤ë„"

          def color_label(label):
              colors = {"ìœ ì§€":"âšª","1ì°¨ë§¤ìˆ˜/ë§¤ë„":"ğŸŸ¨","2ì°¨ë§¤ìˆ˜/ë§¤ë„":"ğŸŸ§","ê°•ë ¥ë§¤ìˆ˜/ë§¤ë„":"ğŸ”´"}
              if "ë§¤ìˆ˜" in label: colors[label] = "ğŸŸ¢"
              return colors.get(label,label)

          def ascii_sparkline(series, length=30):
              if series.empty: return ""
              data = series[-length:]
              min_v, max_v = data.min(), data.max()
              if min_v==max_v: return "â”€"*length
              blocks = "â–â–‚â–ƒâ–„â–…â–†â–‡â–ˆ"
              s = ""
              for v in data:
                  idx = int((v-min_v)/(max_v-min_v)*(len(blocks)-1))
                  s+=blocks[idx]
              return s

          # ---------- ì‹œì„¸ ----------
          gld = yf_close_series("GLD"); tlt = yf_close_series("TLT")
          qqq = yf_close_series("QQQ"); spy = yf_close_series("SPY")
          copper = yf_close_series("HG=F"); gold_fut = yf_close_series("GC=F")

          # ---------- ê²½ì œì§€í‘œ ----------
          dgs10 = fred_series("DGS10"); dgs2 = fred_series("DGS2")
          real10 = dgs10 - fred_series("CPIAUCSL").pct_change(12)*100
          yield_curve = dgs10 - dgs2
          dxy = fred_series("DTWEXBGS")
          pmi = fred_series("NAPM")
          vix = fred_series("VIXCLS")
          hy_oas = fred_series("BAMLH0A0HYM2")
          five_y5y = fred_series("T5YIFR")

          # ---------- ê¸°ìˆ ì§€í‘œ ----------
          gld_rsi = compute_rsi(gld); tlt_rsi = compute_rsi(tlt); qqq_rsi = compute_rsi(qqq)
          spy_mom30 = spy.pct_change(30)*100 if len(spy)>=31 else pd.Series([0])
          copper_gold_ratio = copper.iloc[-1]/gold_fut.iloc[-1] if not copper.empty and not gold_fut.empty else None

          # ---------- ì ìˆ˜ ----------
          def calc_asset_score(rsi, other_factors):
              base = score_directional(rsi)
              for val, dir_high, weight in other_factors:
                  base += score_directional(val, dir_high)*weight
              return max(0.0,min(1.0, base/len(other_factors)))

          gld_score = calc_asset_score(gld_rsi.iloc[-1],
                                       [(vix.iloc[-1], False, 1),
                                        (pmi.iloc[-1], True,1),
                                        (copper_gold_ratio, True,1),
                                        (spy_mom30.iloc[-1], True,1)])
          tlt_score = calc_asset_score(tlt_rsi.iloc[-1],
                                       [(real10.iloc[-1], True,1),
                                        (yield_curve.iloc[-1], True,1),
                                        (five_y5y.iloc[-1], True,1),
                                        (hy_oas.iloc[-1], True,1)])

          # ---------- QQQ ì ìˆ˜ Î±/Î² ìµœì í™” ----------
          def calc_qqq_score(rsi, alpha, beta, gld_score, tlt_score):
              base = score_directional(rsi)
              q_score = base + alpha*((gld_score+tlt_score)/2-0.5) + beta*(base-0.5)
              return max(0.0,min(1.0,q_score))

          best_alpha,best_beta,max_corr=0,0,-1
          for a in np.arange(0,1.05,0.05):
              for b in np.arange(0,0.51,0.05):
                  q_scores=[calc_qqq_score(qqq_rsi.iloc[i],a,b,
                                           score_directional(gld_rsi.iloc[i]),
                                           score_directional(tlt_rsi.iloc[i])) for i in range(len(qqq_rsi))]
                  corr=np.corrcoef(q_scores[14:],qqq.pct_change().dropna()[14:])[0,1]
                  if corr>max_corr: max_corr,best_alpha,best_beta=corr,a,b

          qqq_score=calc_qqq_score(qqq_rsi.iloc[-1],best_alpha,best_beta,gld_score,tlt_score)

          # ---------- ê¶Œê³  ----------
          gld_label = decide_label(gld_score); gld_alloc=dynamic_allocation(gld_score)
          tlt_label = decide_label(tlt_score); tlt_alloc=dynamic_allocation(tlt_score)
          qqq_label = decide_label(qqq_score); qqq_alloc=dynamic_allocation(qqq_score)

          # ---------- Telegram ë©”ì‹œì§€ ----------
          lines=[
          f"ğŸ“Š GLD / TLT / QQQ ìƒì„¸ ëª¨ë‹ˆí„°",
          f"ì‹œê°: {now}",
          "",
          f"=== GLD === {color_label(gld_label)}",
          f"ì ìˆ˜: {round(gld_score*100,1)}% (ë¶„í•  {gld_alloc}%)  ìµœê·¼ 30ì¼: {ascii_sparkline(gld)}",
          f"RSI={round(gld_rsi.iloc[-1],1)} VIX={round(vix.iloc[-1],1)} PMI={round(pmi.iloc[-1],1)} Cu/Gold={round(copper_gold_ratio,4)}",
          "",
          f"=== TLT === {color_label(tlt_label)}",
          f"ì ìˆ˜: {round(tlt_score*100,1)}% (ë¶„í•  {tlt_alloc}%)  ìµœê·¼ 30ì¼: {ascii_sparkline(tlt)}",
          f"RSI={round(tlt_rsi.iloc[-1],1)} 10y={round(dgs10.iloc[-1],2)} 2y={round(dgs2.iloc[-1],2)} 10y-2y={round(yield_curve.iloc[-1],2)} Real10={round(real10.iloc[-1],2)} 5y5y={round(five_y5y.iloc[-1],2)}",
          "",
          f"=== QQQ === {color_label(qqq_label)}",
          f"ì ìˆ˜: {round(qqq_score*100,1)}% (ë¶„í•  {qqq_alloc}%)  ìµœê·¼ 30ì¼: {ascii_sparkline(qqq)}",
          f"RSI={round(qqq_rsi.iloc[-1],1)} Î±={round(best_alpha,2)} Î²={round(best_beta,2)} ê³¼ê±°ìƒê´€={round(max_corr,2)}",
          "",
          "ì°¸ê³ : ê¶Œê³ ëŠ” ìë™ë§¤ë§¤ ì•„ë‹˜. ì‹¤ì œ ë§¤ë§¤ëŠ” ì‚¬ìš©ì íŒë‹¨ í•„ìˆ˜."
          ]

          message="\n".join(lines)
          try:
              requests.post(f"https://api.telegram.org/bot{BOT}/sendMessage",
                            data={"chat_id":CHAT,"text":message}, timeout=25)
          except Exception as e:
              print("Telegram ì „ì†¡ ì‹¤íŒ¨:", e)
          PY
