name: GLD_TLT_Final_Detailed_Monitor

on:
  schedule:
    - cron: '0 * * * *'   # ë§¤ ì •ê° ì‹¤í–‰ (1ì‹œê°„ë§ˆë‹¤)
  workflow_dispatch:

jobs:
  monitor:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install Python deps
        run: |
          python -m pip install --upgrade pip
          pip install requests pandas numpy yfinance

      - name: Run GLD/TLT Detailed Monitor
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
          FRED_API_KEY: ${{ secrets.FRED_API_KEY }}
        run: |
          python - <<'PY'
          import os, sys, math, traceback
          import requests, pandas as pd, numpy as np
          import yfinance as yf
          from datetime import datetime

          # ---------- í™˜ê²½í™•ì¸ ----------
          BOT = os.getenv("TELEGRAM_BOT_TOKEN")
          CHAT = os.getenv("TELEGRAM_CHAT_ID")
          FRED_KEY = os.getenv("FRED_API_KEY")

          def log(*a, **k):
              print(*a, **k); sys.stdout.flush()

          if not BOT or not CHAT or not FRED_KEY:
              log("ERROR: í•„ìˆ˜ Secrets ëˆ„ë½. TELEGRAM_BOT_TOKEN / TELEGRAM_CHAT_ID / FRED_API_KEY í™•ì¸í•˜ì‹­ì‹œì˜¤.")
              sys.exit(1)

          now = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S UTC")
          log("ì‹¤í–‰ì‹œê°:", now)

          # ---------- ìœ í‹¸: FRED ì•ˆì „ í˜¸ì¶œ ----------
          def fred_series(series_id, limit=400):
              try:
                  url = "https://api.stlouisfed.org/fred/series/observations"
                  params = {"series_id": series_id, "api_key": FRED_KEY, "file_type": "json", "limit": limit, "sort_order":"desc"}
                  r = requests.get(url, params=params, timeout=30); r.raise_for_status()
                  obs = r.json().get("observations", [])
                  vals = [(o.get("date"), o.get("value")) for o in obs if o.get("value") not in (".", "", None)]
                  if not vals:
                      return pd.Series(dtype=float)
                  df = pd.DataFrame(vals, columns=["date","value"])
                  df["value"] = pd.to_numeric(df["value"], errors="coerce")
                  df["date"] = pd.to_datetime(df["date"])
                  df = df.sort_values("date").reset_index(drop=True)
                  return df.set_index("date")["value"]
              except Exception as e:
                  log("fred_series error", series_id, e)
                  return pd.Series(dtype=float)

          def fred_latest(series_id):
              s = fred_series(series_id, limit=12)
              return float(s.iloc[-1]) if not s.empty else None

          # ---------- ìœ í‹¸: yfinance ê°€ê²© ì‹œê³„ì—´ ----------
          def yf_close_series(ticker, period="365d"):
              try:
                  t = yf.Ticker(ticker)
                  df = t.history(period=period, interval="1d")
                  return df["Close"].dropna() if df is not None and not df.empty else pd.Series(dtype=float)
              except Exception as e:
                  log("yfinance error", ticker, e)
                  return pd.Series(dtype=float)

          # ---------- ì§€í‘œ ìˆ˜ì§‘ (M2 ì œì™¸) ----------
          # ëª…ëª© ê¸ˆë¦¬
          dgs10 = fred_latest("DGS10")
          dgs2 = fred_latest("DGS2")
          yield_curve = (dgs10 - dgs2) if (dgs10 is not None and dgs2 is not None) else None

          # CPI YoY (ê°„ë‹¨ ê³„ì‚°)
          cpi_series = fred_series("CPIAUCSL", limit=36)
          cpi_yoy = (cpi_series.iloc[-1] / cpi_series.iloc[-13] - 1)*100 if not cpi_series.empty and len(cpi_series)>=13 else None

          # ì‹¤ì§ˆê¸ˆë¦¬(ê·¼ì‚¬)
          real10 = (dgs10 - cpi_yoy) if (dgs10 is not None and cpi_yoy is not None) else None

          # ë‹¬ëŸ¬(ë¬´ì—­ê°€ì¤‘ì§€ìˆ˜ ëŒ€ì²´)
          dxy = fred_latest("DTWEXBGS")

          # PMI (ISM Manufacturing)
          pmi = fred_latest("NAPM")

          # VIX, HY-OAS
          vix = fred_latest("VIXCLS")
          hy_oas = fred_latest("BAMLH0A0HYM2")

          # ê°€ê²© ì‹œê³„ì—´
          gld = yf_close_series("GLD", period="365d")
          tlt = yf_close_series("TLT", period="365d")
          spy = yf_close_series("SPY", period="365d")

          # ê¸°ìˆ ì  ë³´ì¡°
          def compute_rsi(series, period=14):
              s = series.dropna()
              if s.shape[0] < period+2:
                  return None
              delta = s.diff()
              up = delta.clip(lower=0)
              down = -1 * delta.clip(upper=0)
              ma_up = up.rolling(period).mean()
              ma_down = down.rolling(period).mean()
              rs = ma_up / ma_down
              rsi = 100 - (100 / (1 + rs))
              return float(rsi.iloc[-1])

          def mom_pct(series, days=5):
              s = series.dropna()
              if s.shape[0] < days+1:
                  return None
              return float((s.iloc[-1] / s.iloc[-(days+1)] - 1) * 100)

          gld_rsi = compute_rsi(gld, 14)
          tlt_rsi = compute_rsi(tlt, 14)
          spy_mom30 = (spy.iloc[-1] / spy.iloc[-31] - 1) * 100 if not spy.empty and len(spy)>=31 else None

          # GLD ë³´ì¡° ì§€í‘œ (êµ¬ë¦¬/ê¸ˆ ë¹„ìœ¨)
          copper = yf_close_series("HG=F", period="365d")
          gold_fut = yf_close_series("GC=F", period="365d")
          copper_gold_ratio = None
          try:
              if not copper.empty and not gold_fut.empty:
                  m = pd.concat([copper, gold_fut], axis=1, join='inner').dropna()
                  if not m.empty:
                      copper_gold_ratio = float(m.iloc[-1,0] / m.iloc[-1,1])
          except Exception as e:
              copper_gold_ratio = None

          # TLT ë³´ì¡° ì§€í‘œ (10y recent momentum)
          dgs10_series = fred_series("DGS10", limit=120)
          longrate_mom10 = None
          try:
              if not dgs10_series.empty and len(dgs10_series) >= 11:
                  longrate_mom10 = float((dgs10_series.iloc[-1] / dgs10_series.iloc[-11] - 1) * 100)
          except:
              longrate_mom10 = None

          # ---------- ê°€ì¤‘ì¹˜(ê· í˜•í˜•) ì„¤ì • ----------
          # ê³µí†µ ê°€ì¤‘ì¹˜ (ê° 8)
          common_w = {"Real10":8, "DXY":8, "YieldCurve":8, "PMI":8, "SPY_mom":8}
          # GLD ì „ìš© ê°€ì¤‘ì¹˜
          gld_w = {"GLD_RSI":8, "GLD_shares":7, "CopperGold":8, "VIX":7}
          # TLT ì „ìš© ê°€ì¤‘ì¹˜
          tlt_w = {"Real10":8, "FiveY5Y":7, "BondAuction":8, "LongRateMom":7}

          # ---------- ì ìˆ˜ ì‚°ì • í•¨ìˆ˜ (ê°„ë‹¨ ì•ˆì •í˜•) ----------
          def score_directional(val, dir_high=True):
              # dir_high=True: higher value => ë” ìœ„í—˜(ë§¤ë„ ìœ ë¦¬)
              # dir_high=False: lower value => ë” ìœ„í—˜(ë§¤ë„ ìœ ë¦¬)
              if val is None:
                  return 0.0
              try:
                  v = float(val)
              except:
                  return 0.0
              # ê°„ë‹¨ ì •ê·œí™”: logistic-like mapping
              if dir_high:
                  sc = v / (abs(v) + 10.0)
              else:
                  sc = (10.0 - v) / (10.0 + abs(v))
              sc = max(0.0, min(1.0, sc))
              return sc

          # ---------- ê³µí†µ ê°’ ë§¤í•‘ (risk-on ë°©í–¥=ë°©ì–´ìì‚° ë§¤ë„ ìœ ë¦¬) ----------
          # Real10: ë‚®ì„ìˆ˜ë¡ risk-on for equities (í•˜ì§€ë§Œ TLTì—ëŠ” ë†’ì„ìˆ˜ë¡ ë§¤ë„ ìœ ë¦¬ -> ì²˜ë¦¬ ì‹œ ë°˜ì˜)
          common_vals = {
              "Real10": (real10, False),   # ë‚®ì„ìˆ˜ë¡ risk-on for equities -> for scoring we use False (lower => higher score)
              "DXY": (dxy, False),         # ë‚®ì„ìˆ˜ë¡ risk-on (dxy ë‚®ì„ë•Œ ì£¼ì‹ ìœ ë¦¬)
              "YieldCurve": (yield_curve, True), # ë†’ì„ìˆ˜ë¡ risk-on
              "PMI": (pmi, True),
              "SPY_mom": (spy_mom30, True)
          }

          # GLD ì „ìš©
          gld_vals = {
              "GLD_RSI": (gld_rsi, True),       # RSI ë†’ìœ¼ë©´ ë§¤ë„
              "GLD_shares": (None, False),      # ETF ë³´ìœ ëŸ‰ì´ ë‚®ìœ¼ë©´ ë§¤ë„ ìœ ë ¥ (ë°ì´í„° í¬ë°•)
              "CopperGold": (copper_gold_ratio, True),
              "VIX": (vix, False)
          }

          # TLT ì „ìš©
          tlt_vals = {
              "Real10_for_tlt": (real10, True),   # ì‹¤ì§ˆê¸ˆë¦¬ ë†’ì„ìˆ˜ë¡ TLT ì•½í™”
              "FiveY5Y": (fred_latest("T5YIFR"), True),
              "BondAuction": (None, True),
              "LongRateMom": (longrate_mom10, True)
          }

          # ---------- ì ìˆ˜ ì§‘ê³„ ----------
          total_possible = 0.0
          gld_score = 0.0
          tlt_score = 0.0

          # common
          for k,(val,dirflag) in common_vals.items():
              w = common_w.get(k,8)
              s = score_directional(val, dir_high=dirflag)
              gld_score += s * w
              tlt_score += s * w
              total_possible += w

          # gld specific
          for k,(val,dirflag) in gld_vals.items():
              w = gld_w.get(k,7)
              s = score_directional(val, dir_high=dirflag)
              gld_score += s * w
              total_possible += w

          # tlt specific
          for k,(val,dirflag) in tlt_vals.items():
              w = tlt_w.get(k,7)
              s = score_directional(val, dir_high=dirflag)
              tlt_score += s * w
              total_possible += w

          # ì •ê·œí™” %
          gld_pct = (gld_score / total_possible) * 100 if total_possible>0 else 0.0
          tlt_pct = (tlt_score / total_possible) * 100 if total_possible>0 else 0.0

          log("Computed scores â€” GLD:", round(gld_pct,1), "%  TLT:", round(tlt_pct,1), "%")

          # ---------- ê¶Œê³  ê·œì¹™ (A-1 ë§¤í•‘: 50/50 ë¶„í• ) ----------
          def decide_by_pct(pct):
              # returns (label, p1%, p2%)
              if pct < 40:
                  return ("ìœ ì§€", 0, 0)
              if pct < 70:
                  return ("1ì°¨ë§¤ë„", 50, 50)   # ì‚¬ìš©ì ìš”ì²­: ë¶„í•  50/50
              if pct < 90:
                  return ("2ì°¨ë§¤ë„", 50, 50)
              return ("ê°•ë ¥ë§¤ë„", 50, 50)

          gld_label, gld_p1, gld_p2 = decide_by_pct(gld_pct)
          tlt_label, tlt_p1, tlt_p2 = decide_by_pct(tlt_pct)

          # ---------- íŠ¸ë¦¬ê±° ëª©ë¡(ìš”ì•½ìš©) ----------
          triggered_gld = []
          triggered_tlt = []

          # GLD triggers (ìƒ˜í”Œ ê¸°ì¤€)
          if gld_rsi is not None and gld_rsi >= 70: triggered_gld.append(f"RSI {round(gld_rsi,1)}>=70")
          if copper_gold_ratio is not None and copper_gold_ratio > 0.03: triggered_gld.append(f"Cu/Gold {round(copper_gold_ratio,4)}â†‘")
          if vix is not None and vix <= 15: triggered_gld.append(f"VIX {round(vix,1)}<=15")
          if pmi is not None and pmi >= 50: triggered_gld.append(f"PMI {round(pmi,1)}>=50")
          if spy_mom30 is not None and spy_mom30 >= 2.0: triggered_gld.append(f"SPY_mom {round(spy_mom30,2)}%")

          # TLT triggers
          if longrate_mom10 is not None and longrate_mom10 > 0.1: triggered_tlt.append(f"10y mom {round(longrate_mom10,2)}%")
          if yield_curve is not None and yield_curve >= 0.5: triggered_tlt.append(f"10y-2y {round(yield_curve,2)}%")
          fivf = fred_latest("T5YIFR")
          if fivf is not None and fivf >= 2.5: triggered_tlt.append(f"5y5y {round(fivf,2)}")
          if real10 is not None and real10 >= 2.0: triggered_tlt.append(f"Real10 {round(real10,2)}%")
          if hy_oas is not None and hy_oas <= 350: 
              triggered_gld.append(f"HY {int(hy_oas)}bp"); triggered_tlt.append(f"HY {int(hy_oas)}bp")

          # ---------- ìƒì„¸í˜• ë©”ì‹œì§€ êµ¬ì„± ----------
          lines = []
          lines.append("ğŸ“‹ GLD / TLT ìƒì„¸ ê¶Œê³  ë¦¬í¬íŠ¸")
          lines.append(f"ì‹œê°: {now}")
          lines.append("")
          # GLD section
          lines.append("=== GLD ===")
          lines.append(f"ìµœì¢…ì ìˆ˜: {round(gld_pct,1)}%  â†’ ê¶Œê³ : {gld_label}  (ë¶„í•  50/50 if sell)")
          lines.append("ì§€í‘œê°’(ì£¼ìš”):")
          lines.append(f"â€¢ GLD í˜„ì¬ê°€: {gld.iloc[-1] if not gld.empty else 'NA'}  (RSI={round(gld_rsi,1) if gld_rsi is not None else 'NA'})")
          lines.append(f"â€¢ VIX: {round(vix,1) if vix is not None else 'NA'}  â€¢ PMI: {round(pmi,1) if pmi is not None else 'NA'}")
          lines.append(f"â€¢ Copper/Gold ratio: {round(copper_gold_ratio,4) if copper_gold_ratio is not None else 'NA'}")
          lines.append("ê¸°ì—¬ìš”ì¸(ê°„ë‹¨):")
          for k,(val,dirflag) in common_vals.items():
              contrib = round(score_directional(val, dirflag) * common_w.get(k,8),2)
              lines.append(f"  - {k}: val={val if val is not None else 'NA'} contrib={contrib}/{common_w.get(k,8)}")
          for k,(val,dirflag) in gld_vals.items():
              w = gld_w.get(k,7)
              contrib = round(score_directional(val, dirflag) * w,2)
              lines.append(f"  - {k}: val={val if val is not None else 'NA'} contrib={contrib}/{w}")
          lines.append("íŠ¸ë¦¬ê±°(ìš”ì•½): " + (", ".join(triggered_gld) if triggered_gld else "None"))
          lines.append("")

          # TLT section
          lines.append("=== TLT ===")
          lines.append(f"ìµœì¢…ì ìˆ˜: {round(tlt_pct,1)}%  â†’ ê¶Œê³ : {tlt_label}  (ë¶„í•  50/50 if sell)")
          lines.append("ì§€í‘œê°’(ì£¼ìš”):")
          lines.append(f"â€¢ TLT í˜„ì¬ê°€: {tlt.iloc[-1] if not tlt.empty else 'NA'}  (10y mom={round(longrate_mom10,2) if longrate_mom10 is not None else 'NA'}%)")
          lines.append(f"â€¢ 10y: {round(dgs10,2) if dgs10 is not None else 'NA'}  â€¢ 2y: {round(dgs2,2) if dgs2 is not None else 'NA'}  â€¢ 10y-2y: {round(yield_curve,2) if yield_curve is not None else 'NA'}")
          lines.append(f"â€¢ Real10(ê·¼ì‚¬): {round(real10,2) if real10 is not None else 'NA'}  â€¢ 5y5y: {round(fivf,2) if fivf is not None else 'NA'}")
          lines.append("ê¸°ì—¬ìš”ì¸(ê°„ë‹¨):")
          for k,(val,dirflag) in common_vals.items():
              contrib = round(score_directional(val, dirflag) * common_w.get(k,8),2)
              lines.append(f"  - {k}: val={val if val is not None else 'NA'} contrib={contrib}/{common_w.get(k,8)}")
          for k,(val,dirflag) in tlt_vals.items():
              w = tlt_w.get(k,7)
              contrib = round(score_directional(val, dirflag) * w,2)
              lines.append(f"  - {k}: val={val if val is not None else 'NA'} contrib={contrib}/{w}")
          lines.append("íŠ¸ë¦¬ê±°(ìš”ì•½): " + (", ".join(triggered_tlt) if triggered_tlt else "None"))
          lines.append("")
          lines.append("ì°¸ê³ : ê¶Œê³ ëŠ” ìë™ë§¤ë§¤ ì•„ë‹˜. ì‹¤ì œ ë§¤ë§¤ëŠ” ì‚¬ìš©ì íŒë‹¨ í•„ìˆ˜.")

          message = "\n".join(lines)

          # ---------- ì „ì†¡ ----------
          do_send = (gld_label != "ìœ ì§€") or (tlt_label != "ìœ ì§€")
          if do_send:
              try:
                  url = f"https://api.telegram.org/bot{BOT}/sendMessage"
                  r = requests.post(url, data={"chat_id": CHAT, "text": message}, timeout=25)
                  log("Telegram status:", r.status_code)
              except Exception as e:
                  log("Telegram send error:", e)
          else:
              log("ê¶Œê³  ì—†ìŒ â€” ì•Œë¦¼ ë¯¸ì „ì†¡. Scores:", round(gld_pct,1), round(tlt_pct,1))

          PY
